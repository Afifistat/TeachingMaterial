---
title: "Part I: Introduction"
author: "Laurent Gatto"
---

## References

- [Advanced R](http://adv-r.had.co.nz/), Hadley Wickham.
- [The R Inferno](http://www.burns-stat.com/documents/books/the-r-inferno/), Patrick Burns.
- [An Introduction to the Interactive Debugging Tools in R](http://www.biostat.jhsph.edu/~rpeng/docs/R-debug-tools.pdf), Roger D. Peng.
- [R Programming for Bioinformatics](http://master.bioconductor.org/help/publications/books/r-programming-for-bioinformatics/), Robert Gentleman.

## Overview

- Coding style(s)
- Interactive use and programming
- Environments
- Computing on the language
- Tidy data


## Introduction

> Computers are cheap, and thinking hurts. -- Use Ligges

Simplicity, readability and consistency are a long way towards
robust code.

## Coding style(s)

Why?

> Good coding style is like using correct punctuation. You can manage
> without it, but it sure makes things easier to read.
-- Hadley Wickham

for **consistency** and **readability**.

## Which one?

- [Bioconductor](http://master.bioconductor.org/developers/how-to/coding-style/)
- [Hadley Wickham](http://r-pkgs.had.co.nz/style.html)
- [Google](http://google.github.io/styleguide/Rguide.xml)
- ...

## Examples

- Place spaces around all infix operators (`=`, `+`, `-`, `<-`, etc., but *not* `:`)
  and after a comma (`x[i, j]`).
- Spaces before `(` and after `)`.
- Use `<-` rather than `=`.
- Limit your code to 80 characters per line
- Indentation: do not use tabs, use 2 (HW)/4 (Bioc) spaces
- Function names: use verbs
- Variable names: camelCaps (Bioc)/ `_` (HW) (but not a `.`)
- Prefix non-exported functions with a ‘.’ (Bioc).
- Class names: start with a capital
- Comments: `# ` or `## ` (from emacs)

## [`formatR`](https://cran.rstudio.com/web/packages/formatR/index.html)

```{r}
library("formatR")
tidy_eval(text = c("a=1+1;a  # print the value", "matrix ( rnorm(10),5)"),
          arrow = TRUE)
```

## [`BiocCheck`](http://bioconductor.org/packages/devel/bioc/html/BiocCheck.html)

```
* Checking function lengths................
  The longest function is 677 lines long
  The longest 5 functions are:
* Checking formatting of DESCRIPTION, NAMESPACE, man pages, R source,
  and vignette source...
    * CONSIDER: Shortening lines; 616 lines (11%) are > 80 characters
      long.
    * CONSIDER: Replacing tabs with 4 spaces; 3295 lines (60%) contain
      tabs.
    * CONSIDER: Indenting lines with a multiple of 4 spaces; 162 lines
      (2%) are not.
```

## Style changes over time

![Style changes over time](./figs/style.png)

## Interactive use vs programming: `drop`

```{r, eval=FALSE}
head(cars)
head(cars[, 1])
head(cars[, 1, drop = FALSE])
```

## Interactive use vs programming: `sapply/lapply`

```
df1 <- data.frame(x = 1:3, y = LETTERS[1:3])
sapply(df1, class)
df2 <- data.frame(x = 1:3, y = Sys.time() + 1:3)
sapply(df2, class)
```
## Ineractive use vs programming

Moving from using R to programming R is *abstraction*, *automation*,
*generalisation*.

## Semantics

- *pass-by-value* copy-on-modify
- *pass-by-reference*: environments, S4 Reference Classes

## Environments

### Motivation

- Data structure that enables *scoping* (see later).
- Have reference semantics
- Useful data structure on their own

### Definition (1)

An environment associates, or *binds*, names to values in memory.
Variables in an environment are hence called *bindings*.

## Creating and populate environments

```{r, eval=FALSE}
e <- new.env()
e$a <- 1
e$b <- LETTERS[1:5]
e$c <- TRUE
e$d <- mean
```

```{r, eval=FALSE}
e$a <- e$b
e$a <- LETTERS[1:5]
```

- Objects in environments have unique names
- Objects in different environments can of course have identical names
- Objects in an environment have no order
- Environments have parents

## Definition (2)

An environment is composed of a *frame* that contains the name-object
bindings and a parent (enclosing) environment.

## Relationship between environments

Every environment has a parent (enclosing) environment

```{r, eval=FALSE}
e <- new.env()
parent.env(e)
```
Current environment

```{r}
environment()
```

Noteworthy environments

```{r, eval=FALSE}
globalenv()
emptyenv()
baseenv()
```

All parent of `R_GlobalEnv`:

```{r}
search()
as.environment("package:stats")
```

Listing objects in an environment

```{r}
ls() ## default is R_GlobalEnv
ls(envir = e)
ls(pos = 1)
```

```{r}
search()
```

Note: Every time a package is loaded with `library`, it is inserted in
the search path after the `R_GlobalEnv`.

## Accessors and setters

- In addition to `$`, one can also use `[[`, `get` and `assign`.
- To check if a name exists in an environmet (or in any or its parents), one can use `exists`.
- Compare two environments with `identical` (not `==`).

## Exercise

- Draw a few environments with variables and ask to reproduce in R.

## Where is a symbol defined?

`pryr::where()`

## Lexical scoping

- Objects in environments have unique names
- Objects in different environments can of course have identical names.
- If a name is not found in the current environment, it is looked up
  in the parent (enclosing) from. 
- If it is not found in the parent (enclosing) frame, it is looked up
  in the parent's parent frame, and so on...

```{r, eval = FALSE}
search()
mean <- function(x) cat("The mean is", sum(x)/length(x), "\n")
mean(1:10)
base::mean(1:10)
rm(mean)
mean(1:10)
```

## Assignments

- `<-` assigns/creates in the current environment

- `<<-` (deep assignment) never creates a variable in the current
  environment, but modifies an existing variable in the current or
  first enclosing environment where that name is defined. 
  
- If `<<-` does not find the name, it will create the variable in the global environment.

## Using environments

Most environments are created when creating and calling functions. They are also used in packages:

- Used in packages: *package* and *namespace* environments

There are several reasons to create then manually.

- Reference semantics
- Avoiding copies
- Package state
- As a hashmap

## Computing on the language



## Tidy data

(interactive use)
- tidy data
- pipe operator

