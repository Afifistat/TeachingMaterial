
\begin{frame}{\R's build-in \texttt{C} interfaces}
  \begin{block}{}
    \begin{itemize}
    \item Better know how to program in \texttt{C}.
    \item Documentation is not always easy to follow: R-Ext, R Internals as well as \R~and other package's code.
    \end{itemize}
  \end{block}
  \begin{block}{\texttt{.C}}
    \begin{itemize}
    \item \textit{Easy} way
    \item Arguments and return values must be \textit{primitive} (vectors of doubles or integers)
    \end{itemize}
  \end{block}
  \begin{block}{\texttt{.Call}}
    \begin{itemize}
    \item Accepts \R~data structures as arguments and return values (\texttt{SEXP} and friends) 
      (no type checking is done though).
    \item Memory management: memory allocated for R objects is garbage collected. 
      Thus \R~objects in \texttt{C} code, you must be explicitely \texttt{PROTECT}ed to 
      avoid being \texttt{gc()}ed, and subsequently \texttt{UNPROTECT}ed.      
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]{\texttt{.Call} example}
  \begin{example}
    \tiny
\begin{verbatim}
#include <R.h> 
#include <Rdefines.h>

SEXP gccount(SEXP inseq) {
  int i, l;
  SEXP ans, dnaseq;    
  PROTECT(dnaseq = STRING_ELT(inseq, 0)); 
  l = LENGTH(dnaseq); 
  printf("length %d\n",l);
  PROTECT(ans = NEW_NUMERIC(4));

  for (i = 0; i < 4; i++) 
    REAL(ans)[i] = 0;

  for (i = 0; i < l; i++) {
    char p = CHAR(dnaseq)[i];
    if (p=='A') 
      REAL(ans)[0]++;
    else if (p=='C') 
      REAL(ans)[1]++;
    else if (p=='G') 
      REAL(ans)[2]++;
    else if (p=='T') 
      REAL(ans)[3]++;
    else 
      error("Wrong alphabet");
  }
  UNPROTECT(2);
  return(ans);
}
\end{verbatim}
  \end{example}
\end{frame}

\begin{frame}{Using your \texttt{C} code}
  \begin{block}{Directly}
    \begin{enumerate}
      \item Create a shared library: \texttt{R CMD SHLIB gccount.c}
      \item Load the shared object: \texttt{dyn.load("gccount.so")}
      \item Create an \R~function that uses it: \texttt{gccount <- function(inseq) .Call("gccount",inseq)}
      \item Use you \texttt{C} code: \texttt{gccount("GACAGCATCA")}
    \end{enumerate}
  \end{block}
  \begin{block}{In a package}
    \begin{itemize}
    \item Document you function.
    \item Export the shared objects with \texttt{useDynLib} in your \texttt{NAMESPACE}.
    \item (Without \texttt{NAMESPACE}, overwrite \texttt{.First.lib} to \texttt{dyn.load} you shared object.)
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]{\Rpackage{sequences} example}
  \begin{example}
    In \Rpackage{sequences}, we have
    \begin{itemize}
      \item The \texttt{gccount.c} code in \texttt{src}.
      \item Defined a \R~ function in \texttt{R/functions.R}
\begin{verbatim}
gccount <- function(inseq) {
  .Call("gccount",
        inseq,
        PACKAGE="sequences")
}
\end{verbatim}
\item Written the \texttt{man/gccount.Rd} man page.
\item Exported the function in \texttt{NAMESPACE} using \texttt{export(gccount)} and the shared library with \texttt{useDynLib(sequences)}
    \end{itemize}
\end{example}
\end{frame}

\begin{frame}[fragile]{\Rpackage{sequences} example}
  \begin{example}
<<lib,echo=FALSE>>=
library(sequences)
@ 
<<gccount,echo=TRUE>>=
s <- "GACTACGA"
gccount
gccount(s)
table(strsplit(s,""))
@ 
  \end{example}
\end{frame}
