<<recache, echo=FALSE, message = FALSE>>=
library("sequences")
x <- "ACCGGGTTTT"
gccountr <- function(x) table(strsplit(x, "")[1])
source("./src/ingccount.R")
source("./src/ingccount2.R")
if (!file.exists("src/gccount.so"))
  system("R CMD SHLIB src/gccount.c")
dyn.load("src/gccount.so")
gccountC <- 
  function(inseq) .Call("gccount", inseq)
@ 

\section{The \texttt{Rcpp} package}

\begin{frame}
  \begin{block}{The \Rpackage{Rcpp} package}
    \begin{itemize}
    \item Dirk Eddelbuettel and Romain Francois, with contributions by Douglas Bates, John Chambers and JJ Allaire
    \item \R functions as well as a \Cpp library which facilitate the integration of \R and \Cpp
    \item Also very well suited for \C
    \item \url{http://www.rcpp.org/}
    \end{itemize}    
  \end{block}
  \pause
  \begin{block}{Associated packages}
    \begin{itemize}
    \item \Rpackage{RcppArmadillo} -- Armadillo templated \Cpp library for linear algebra. 
    \item \Rpackage{RcppEigen} -- high-performance Eigen linear algebra library.
    \item \Rpackage{RInside} -- use \R from inside another \Cpp by wrapping the existing \R embedding API 
      in an easy-to-use \Cpp class.
    \end{itemize}    
  \end{block}
\end{frame}


\begin{frame}[fragile]
  \begin{block}{}
    \Rpackage{Rcpp} is a great package for writing both \C and \Cpp code:
    \begin{itemize}
    	\item It comes with \textbf{loads} of documentation and examples. 
    	\item All basic \R types are implemented as \Cpp classes.
    	\item No need to worry about garbage collection. 
    \end{itemize}
  \end{block}
\end{frame}

\subsection{As a replacement for \Rfunction{.Call}}

  
\begin{frame}
  \begin{block}{Standard template library}
    
  \end{block}
\end{frame}

\begin{frame}{\url{./src/ingccount2.R}}
  \tiny
  \verbatiminput{src/ingccount2.R}
\end{frame}

\begin{frame}[fragile]
<<ingccount2>>=
x <- "ACCGGGTTTT"
source("src/ingccount2.R")
ingccount2(x)
@   
\end{frame}

\begin{frame}{\url{./src/ingccount2.R}}
  \tiny
  \verbatiminput{src/gccount2.cpp}
\end{frame}


\begin{frame}[fragile]
  \begin{block}{Using in a package}
    \begin{enumerate}
      \item You will need a \texttt{Makevars} file in the \code{src} directory
      \item Modify \texttt{DESCRIPTION} file: \\
      	\code{Depends: Rcpp} \\
      	\code{LinkingTo: Rcpp}
      \item Create an \R function that uses it
<<gccount2r, tidy = FALSE, eval = FALSE>>=
gccount2 <- function(inseq) 
  .Call("gccount2", inseq, PACKAGE = "mypackage")
@         
      \item Document the \R function
      \item Export the \R function and \texttt{useDynLib(mypackge)} in the \texttt{NAMESPACE}
    \end{enumerate}
  \end{block}
	See package \texttt{sequences} for a working example.
\end{frame}


\begin{frame}[fragile]
  \begin{block}{Benchmarking}
\scriptsize    
<<bench, cache = TRUE, tidy = FALSE>>=
library(microbenchmark)
microbenchmark(gccountr(x),
               ingccount(x),  ## inline
               ingccount2(x), ## cppFunction
               sequences::gccount(x),
               sequences::gccount2(x),
               times = 1e4)
@     
  \end{block}  
\end{frame}


\begin{frame}[fragile]
  Could we do better in \R? (should be asked first, really)
  \pause
\scriptsize    
<<usetabulate, tidy = FALSE>>=
gccountr2 <- 
  function(x) tabulate(factor(strsplit(x, "")[[1]]))
@ 
\pause
<<bench2, cache = TRUE, tidy = FALSE>>=
microbenchmark(gccountr(x),
               gccountr2(x),
               ingccount(x),  ## inline
               ingccount2(x), ## cppFunction
               sequences::gccount(x),
               sequences::gccount2(x),
               times = 1e4)
@     
\end{frame}

\subsection{The pi example}

\subsection{Rcpp classes}

