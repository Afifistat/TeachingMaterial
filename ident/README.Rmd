# Indentification data using `mzR`, `mzID`, `MSnID`

```{r env, echo=FALSE}
library(BiocStyle)
suppressPackageStartupMessages(library("mzR"))
suppressPackageStartupMessages(library("MSnbase"))
```
## Handling identification data

There are two packages that can be used to parse `mzIdentML` files,
namely `mzR` (that we have already used for raw data) and `mzID`. The
major difference is that the former leverages C++ code from
`proteowizard` and is hence faster than the latter (which uses the
`XML` R package). They both work in similar ways.

```{r, echo = FALSE}
x <- RforProteomics:::msDataTab()
sel <- x[, 1] %in% c("Identification")
knitr::kable(x[sel, ])
```

We are going to use the following identification file in this practical:

```{r}
library("msdata")
idf <- ident(full.names = TRUE)
basename(idf)
```

### mzID

The main functions are `mzID` to read the data into a dedicated data
class and `flatten` to transform it into a `data.frame`. 

```{r id}
library("mzID")
id <- mzID(idf)
id
```

Various data can be extracted from the `mzID` object, using one the
accessor functions such as `database`, `sofware`, `scans`, `peptides`,
... The object can also be converted into a `data.frame` using the
`flatten` function.

```{r fid}
head(flatten(id))
```

#### Exercise

Open the `r basename(idf)` file as shown above. What software and how many
proteins were in the database used to perform the search?

### `mzR`

The `mzR` interface provides a similar interface. It is however much
faster as it does not read all the data into memory and only extracts
relevant data on demand. It has also accessor functions such as
`softwareInfo`, `mzidInfo`, ... (use `showMethods(classes = "mzRident", where = "package:mzR")`)
to see all available methods.

```{r id2}
library("mzR")
id2 <- openIDfile(idf)
id2
softwareInfo(id2)
```

The identification data can be accessed as a `data.frame` with the
`psms` accessor.

```{r fid2}
head(psms(id2))
```

#### Exercise

Is there a relation between the length of a protein and the number of
identified peptides, conditioned by the (average) e-value of the
identifications?

```{r, ex_id, echo=FALSE, eval=FALSE}
fid <- flatten(id)
x <- by(fid, fid$accession,
        function(x)
            c(unique(x$length),
              length(unique(x$pepseq)),
              mean(x$'ms-gf:specevalue')))
x <- data.frame(do.call(rbind, x))
colnames(x) <- c("plength", "npep", "eval")
x$bins <- cut(x$eval, summary(x$eval))
library("lattice")
xyplot(plength ~ npep | bins, data = x)
```

## Adding identification data to raw data

Here are two matching raw and identiciation data files:

```{r}
libary("MSnbase")
## find path to a mzXML file
rwf <- dir(system.file(package = "MSnbase", dir = "extdata"),
           full.name = TRUE, pattern = "mzXML$")
## find path to a mzIdentML file
idf <- dir(system.file(package = "MSnbase", dir = "extdata"),
           full.name = TRUE, pattern = "dummyiTRAQ.mzid")
```

We first create the raw data object:

```{r}
msexp <- readMSData(rwf, verbose = FALSE)
head(fData(msexp))
```

The simply add identification data. The matching of spectra from the
raw data and the PSMs from the identification data is done internally.

```{r}
msexp <- addIdentificationData(msexp, idf)
head(fData(msexp))
```

## Visualising identification data

For this part, let's use a ready made `MSnExp` object that is
distributed with the `MSnbase` package. Simply use the `data()`
function with the name of the desired data.

```{r}
library("MSnbase")
data(itraqdata)
```

### Annotated spectra and spectra comparison

```{r id1, message=FALSE, fig.width=15, message=FALSE}
par(mfrow = c(1, 2))
itraqdata2 <- pickPeaks(itraqdata, verbose = FALSE)
s <- "SIGFEGDSIGR"
plot(itraqdata2[[14]], s, main = s)
plot(itraqdata2[[25]], itraqdata2[[28]], sequences = rep("IMIDLDGTENK", 2))
```

The annotation of spectra is obtained by simulating fragmentation of a
peptide and matching observed peaks to fragments:

```{r fag}
calculateFragments("SIGFEGDSIGR")
```

Visualising a pair of spectra means that we can access them, and that,
in addition to plotting, we can manipulate them and perform
computations. The two spectra corresponding to the `IMIDLDGTENK`
peptide, for example have 

```{r}
compareSpectra(itraqdata2[[25]], itraqdata2[[28]], fun = "common")
```

common peaks, a correlation of

```{r}
compareSpectra(itraqdata2[[25]], itraqdata2[[28]], fun = "cor")
```

and a dot product of 

```{r}
compareSpectra(itraqdata2[[25]], itraqdata2[[28]], fun = "dotproduct")
```

See `?compareSpectra` for details.

There are 2 Bioconductor packages for peptide-spectrum matching
directly in R, namely `r Biocpkg("MSGFplus")` and `r Biocpkg("rTANDEM")`, 
replying on `MSGF+` and `X!TANDEM` respectively.
See also the `r Biocpkg("MSGFgui")` package for visualisation of
identification data.


## Exploration and Assessment of Confidence of LC-MSn Proteomics Identifications using `MSnID`

Extracts MS/MS ID data from mzIdentML (leveraging the `mzID` package)
or text files. After collating the search results from multiple
datasets it assesses their identification quality and optimize
filtering criteria to achieve the maximum number of identifications
while not exceeding a specified false discovery rate. Also contains a
number of utilities to explore the MS/MS results and assess missed and
irregular enzymatic cleavages, mass measurement accuracy, etc.

Let's reproduce the analysis described the `MSnID` vignette. Open it
with

```{r, eval = FALSE}
vignette("msnid_vignette", package = "MSnID")
```
